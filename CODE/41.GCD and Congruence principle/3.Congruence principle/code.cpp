// 同于原理：

// 需求：
// 当需要求很多数(+、-、*、/) 之后得出的答案让后 % 上一个很大的数，求结果时，
// 如果直接一个一个算，会很慢
//
// 结论：
// 1）固定位数 32位、64位 的 (+、-、*、/) 时间复杂度：O(1)
// 2）当位数比较大 如 k 位时：
//      operation(+、-)的时间复杂度：O(K)
//      operation(*、/)的时间复杂度：O(K^2)

// 一、加法同余原理：求 ((a+b) + (c+d)) % m
//
// 1）加法同余：每做一次加法就取模，从而减少复杂的累加计算
// 
// 2）细节：A+B 时：可能溢出，先用 long long 接住，等取模完后再还原成 int
//
// 3）比较：求 ((a+b) + (c+d)) % m
//
//      1）普通计算：1.A1 = (a+b) 2.B1 = (c+d) 3.C1 = (A+B) 4.D1 = C % m
//
//      2）同余计算：1.A2 = (a+b) 2.B2 = A2 % m 3.C2 = (c+d) 4.D2 = C2 % m 5.E2 = (B2+D2) 6.F2 = E2 % m
//
//      3）两种计算方法的结果比较：D1 == F2



// 二、乘法同余原理：求 ((a*b) * (c*d)) % m
//
// 1）乘法同余：每做一次乘法就取模，从而减少复杂的累加计算
// 
// 2）细节：A*B 时：可能溢出，先用 long long 接住，等取模完后再还原成 int
//
// 3）比较：求 ((a*b) * (c*d)) % m
//
//      1）普通计算：1.A1 = (a*b) 2.B1 = (c*d) 3.C1 = (A*B) 4.D1 = C % m
//
//      2）同余计算：1.A2 = (a*b) 2.B2 = A2 % m 3.C2 = (c*d) 4.D2 = C2 % m 5.E2 = (B2*D2) 6.F2 = E2 % m
//
//      3）两种计算方法的结果比较：D1 == F2



// 三、减法同余原理：求 ((a-b) - (c-d)) % m
//
// 1）减法同余：每做一次减法就取模，从而减少复杂的累加计算
// 
// 2）细节：(a - b) % m = ((a%m) - (b%m) + m) % m
//      1）公式：(A - B) % m 时：C = A%m  D = B%m ，且 C < D    ==> 原式 = (C - D + m)%m
//      2）例子：
//              (72 - 18) % 7： C = 72%7 = 2 ; D = 18%7 = 4
//              ==> C < D 
//              ==> 原式 = (C - D + 7) % 7 = (2 - 4 + 7) % 7 = 5
//
// 3）比较：求 ((a-b) - (c-d)) % m
//      1）普通计算：1.A1 = (a-b) 2.B1 = (c-d) 3.C1 = (A-B) 4.D1 = C % m
//
//      2）同余计算：1.A2 = a % m 2.B2 = b % m 3.C2 = (A2 - B2 + m) % m 
//                  4.D2 = c % m 5.E2 = d % m 6.F2 = (D2 - E2 + m) % m
//                  7.G2 = (C2 - F2 + m) % m
//
//      3）两种计算方法的结果比较：D1 == F2